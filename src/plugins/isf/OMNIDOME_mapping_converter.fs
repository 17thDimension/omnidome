/*{
    "DESCRIPTION": "Generated by Omnidome.",
    "CREDIT": "Generated by Omnidome.",
    "CATEGORIES":
    [
        "Omnidome"
    ],
    "INPUTS":
    [
        {
            "NAME": "inputImage",
            "TYPE": "image"
        },
 {
 "NAME": "inputmap_mode",
  "LABEL" : "Input mapping",
 "VALUES": [
 0,
 1
 ],
 "LABELS": [
 "Equirectangular",
 "Fisheye"
 ],
 "DEFAULT": 0,
 "TYPE": "long"
 },
 {
 "NAME": "outputmap_mode",
  "LABEL" : "Output mapping",
 "VALUES": [
 0,
 1
 ],
 "LABELS": [
 "Equirectangular",
 "Fisheye"
 ],
 "DEFAULT": 0,
 "TYPE": "long"
 },
        {
            "NAME": "map_roll",
            "LABEL" : "Roll",
            "TYPE": "float",
            "DEFAULT": 0.0,
            "MIN": -180.0,
            "MAX": 180.0
        },
        {
            "NAME": "map_pitch",
            "LABEL" : "Pitch",
            "TYPE": "float",
            "DEFAULT": 0.0,
            "MIN": -180.0,
            "MAX": 180.0
        },
        {
            "NAME": "map_yaw",
            "LABEL": "Yaw",
            "TYPE": "float",
            "DEFAULT": 0.0,
            "MIN": -180.0,
            "MAX": 180.0
        },
        {
            "NAME": "fisheye_stretch",
            "LABEL": "Stretch fisheye",
            "TYPE": "float",
            "DEFAULT": 0.0,
            "MIN": 0.0,
            "MAX": 1.0
        }
    ]
}
*/
/******************************************************************
    This file is part of Omnidome.

    DomeSimulator is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    DomeSimulator is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with DomeSimulator.  If not, see <http://www.gnu.org/licenses/>.

    Omnidome is free for non-commercial use. If you want to use it 
    commercially, you should contact the author 
    Michael Winkelmann aka Wilston Oreo by mail:
    me@wilstonoreo.net
**************************************************************************/


#define MAP_EQUIRECTANGULAR 0
#define MAP_FISHEYE 1

////////// ./shaders/util.h //////////

const float PI = 3.14159265358979323846264;

/// Convert degrees to radians
float deg2rad(in float deg)
{
  return deg * PI / 180.0;
}


/// Convert degrees to radians
float rad2deg(in float rad)
{
  return rad / PI * 180.0;
}

float sqr(in float a)
{
  return a*a;
}

/// Calculates the rotation matrix of a rotation around X axis with an angle in radians
mat3 rotateAroundX( in float angle )
{
  float s = sin(angle);
  float c = cos(angle);
  return mat3(1.0,0.0,0.0,
              0.0,  c, -s,
              0.0,  s,  c);
}

/// Calculates the rotation matrix of a rotation around Y axis with an angle in radians
mat3 rotateAroundY( in float angle )
{
  float s = sin(angle);
  float c = cos(angle);
  return mat3(  c,0.0,  s,
              0.0,1.0,0.0,
               -s,0.0,  c);
}

/// Calculates the rotation matrix of a rotation around Z axis with an angle in radians
mat3 rotateAroundZ( in float angle )
{
  float s = sin(angle);
  float c = cos(angle);
  return mat3(  c, -s,0.0,
                s,  c,0.0,
              0.0,0.0,1.0);
}

/// Calculate rotation by given yaw and pitch angles (in degrees!)
mat3 rotationMatrix(in float yaw, in float pitch, in float roll)
{
  return rotateAroundZ(deg2rad(yaw)) * 
         rotateAroundY(deg2rad(pitch)) *
         rotateAroundX(deg2rad(roll));
}


float map_equirectangular(in vec3 normal, out vec2 texCoords)
{
    texCoords.s = fract(atan(normal.y,normal.x) / (2.0*PI));
    texCoords.t = fract(acos(normal.z) / PI);
    return 1.0;
}

float map_equirectangular(in vec2 texCoords, out vec3 normal)
{
    float theta = texCoords.t * PI,
    phi = (0.25 - texCoords.s)* 2.0 * PI;
    float sin_theta = sin(theta);
    normal = normalize(vec3(sin_theta * sin(phi), sin_theta * cos(phi), cos(theta)));
    return 1.0;
}


float map_fisheye(in vec3 n, out vec2 texCoords)
{
    vec3 normal = n;
    normal.z = -normal.z;
    float phi = atan(length(normal.xy),normal.z);
    float r = phi / PI * 2.0 / (1.0 + fisheye_stretch);
    if ((r > 1.0) || (r <= 0.0)) return -1.0;
    float theta = atan(n.x,n.y);
    texCoords.s = fract(0.5 * (1.0 + r* cos(theta)));
    texCoords.t = fract(0.5 * (1.0 + r * sin(theta)));
    return 1.0;
}

float map_fisheye(in vec2 texCoords, out vec3 n)
{
    vec2 uv = texCoords -0.5;
    float phi = atan(uv.x,uv.y);
    float l = length(uv);
    
    if (l > 0.5) return -1.0;
    
    float theta = l *PI *(1.0 + fisheye_stretch);
    float sin_theta = sin(theta);
    n = normalize(vec3(sin_theta * sin(phi), sin_theta * cos(phi), -cos(theta)));
    return 1.0;
}



void main(void)
{
    vec2 uv=gl_FragCoord.xy/RENDERSIZE.xy;
    
    vec3 normal = vec3(0.0,0.0,0.0);
    float result = -1.0;
    
    if (outputmap_mode == MAP_EQUIRECTANGULAR)
    {
        result = map_equirectangular(uv,normal);
    } else
    if (outputmap_mode == MAP_FISHEYE)
    {
        result = map_fisheye(uv,normal);
    }
    if (result < 0.0)
    {
        gl_FragColor = vec4(0.0);
        return;
    }
    
    normal *= rotationMatrix(map_yaw,map_pitch,map_roll);
    
    vec2 texCoords;
    if (inputmap_mode == MAP_EQUIRECTANGULAR)
    {
        result = map_equirectangular(normal,uv);
    } else
    if (inputmap_mode == MAP_FISHEYE)
    {
        result = map_fisheye(normal,uv);
    }
    if (result < 0.0)
    {
        gl_FragColor = vec4(0.0);
        return;
    }
    
    gl_FragColor = texture2DRect(inputImage,uv * _inputImage_imgSize);
}

